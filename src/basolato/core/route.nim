import
  asynchttpserver, asyncdispatch, json, strformat, macros, strutils, os,
  asyncfile, mimetypes, re, tables, times
from osproc import countProcessors
import baseEnv, request, response, header, logger, error_page, resources/ddPage,
  security
export request, header


type Route* = ref object
  httpMethod*:HttpMethod
  path*:string
  action*:proc(r:Request, p:Params):Future[Response]

type MiddlewareRoute* = ref object
  httpMethods*:seq[HttpMethod]
  path*:Regex
  action*:proc(r:Request, p:Params):Future[Response]


proc params*(request:Request, route:Route):Params =
  let url = request.path
  let path = route.path
  let params = Params()
  for k, v in getUrlParams(url, path).pairs:
    params[k] = v
  for k, v in getQueryParams(request).pairs:
    params[k] = v
  for k, v in getRequestParams(request).pairs:
    params[k] = v
  return params

proc params*(request:Request, middleware:MiddlewareRoute):Params =
  let url = request.path
  let path = middleware.path
  let params = Params()
  # for k, v in getUrlParams(url, path).pairs:
  #   params[k] = v
  for k, v in getQueryParams(request).pairs:
    params[k] = v
  for k, v in getRequestParams(request).pairs:
    params[k] = v
  return params

type Routes* = ref object
  withParams: seq[Route]
  withoutParams: OrderedTable[string, Route]
  middlewares: seq[MiddlewareRoute]

proc newRoutes*():Routes =
  return Routes()

proc newRoute(httpMethod:HttpMethod, path:string, action:proc(r:Request, p:Params):Future[Response]):Route =
  return Route(
    httpMethod:httpMethod,
    path:path,
    action:action
  )

proc add*(this:var Routes, httpMethod:HttpMethod, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  let route = newRoute(httpMethod, path, action)
  if path.contains("{"):
    this.withParams.add(route)
  else:
    this.withoutParams[ $httpMethod & ":" & path ] = route

proc middleware*(
  this:var Routes,
  path:Regex,
  action:proc(r:Request, p:Params):Future[Response]
) =
  this.middlewares.add(
    MiddlewareRoute(
      httpMethods: newSeq[HttpMethod](),
      path: path,
      action: action
    )
  )

proc middleware*(
  this:var Routes,
  httpMethods:seq[HttpMethod],
  path:Regex,
  action:proc(r:Request, p:Params):Future[Response]
) =
  this.middlewares.add(
    MiddlewareRoute(
      httpMethods: httpMethods,
      path: path,
      action: action
    )
  )

proc get*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpGet, path, action)

proc post*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPost, path, action)

proc put*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPut, path, action)

proc patch*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPatch, path, action)

proc delete*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpDelete, path, action)

proc head*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpHead, path, action)

proc options*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpOptions, path, action)

proc trace*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpTrace, path, action)

proc connect*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpConnect, path, action)

macro groups*(head, body:untyped):untyped =
  var newNode = ""
  for row in body:
    let rowNode = fmt"""
{row[0].repr}("{head}{row[1]}", {row[2].repr})
"""
    newNode.add(rowNode)
  return parseStmt(newNode)

const errorStatusArray* = [505, 504, 503, 502, 501, 500, 451, 431, 429, 428, 426,
  422, 421, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406,
  405, 404, 403, 401, 400, 307, 305, 304, 303, 302, 301, 300]

macro createHttpCodeError():untyped =
  var strBody = ""
  for num in errorStatusArray:
    strBody.add(fmt"""
of "Error{num.repr}":
  return Http{num.repr}
""")
  return parseStmt(fmt"""
case $exception.name
{strBody}
else:
  return Http400
""")

proc checkHttpCode(exception:ref Exception):HttpCode =
  ## Generated by macro createHttpCodeError.
  ## List is httpCodeArray
  ## .. code-block:: nim
  ##   case $exception.name
  ##   of Error505:
  ##     return Http505
  ##   of Error504:
  ##     return Http504
  ##   of Error503:
  ##     return Http503
  ##   .
  ##   .
  createHttpCodeError


proc serveCore(params:(Routes, int)){.thread.} =
  let (routes, port) = params
  var server = newAsyncHttpServer(true, true)

  proc createResponse(req:Request, route:Route, headers: Headers):Future[Response] {.async, gcsafe.} =
    var response: Response
    var headers = headers
    try:
      let params = req.params(route)
      response = await route.action(req, params)
      response.headers = response.headers & headers
      logger($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
    except Exception:
      headers.set("Content-Type", "text/html; charset=UTF-8")
      let exception = getCurrentException()
      if exception.name == "DD".cstring:
        var msg = exception.msg
        msg = msg.replace(re"Async traceback:[.\s\S]*")
        response = Response(status:Http200, body:ddPage(msg), headers:headers)
      elif exception.name == "ErrorRedirect".cstring:
        headers.set("Location", exception.msg)
        response = Response(status:Http302, body:"", headers:headers)
      else:
        let status = checkHttpCode(exception)
        response = Response(status:status, body:errorPage(status, exception.msg), headers:headers)
        echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
        echoErrorMsg(exception.msg)
    return response

  proc cb(req: Request) {.async, gcsafe.} =
    var
      headers = newDefaultHeaders()
      response: Response
      isMiddleware, isWebApp = false
    # static file response
    if req.path.contains("."):
      let filepath = getCurrentDir() & "/public" & req.path
      if fileExists(filepath):
        let file = openAsync(filepath, fmRead)
        let data = await file.readAll()
        let contentType = newMimetypes().getMimetype(req.path.split(".")[^1])
        headers.set("Content-Type", contentType)
        response = Response(status:Http200, body:data, headers:headers)
    else:
      block middlewareAndApp:
        # middleware:
        for route in routes.middlewares:
          try:
            if route.httpMethods.len > 0:
              if findAll(req.path, route.path).len > 0 and route.httpMethods.contains(req.httpMethod):
                let params = req.params(route)
                response = await route.action(req, params)
                isMiddleware = true
            else:
              if findAll(req.path, route.path).len > 0:
                let params = req.params(route)
                response = await route.action(req, params)
                isMiddleware = true
          except:
            headers.set("Content-Type", "text/html; charset=UTF-8")
            let exception = getCurrentException()
            if exception.name == "ErrorRedirect".cstring:
              headers.set("Location", exception.msg)
              response = Response(status:Http302, body:"", headers:headers)
            elif exception.name == "ErrorAuthRedirect".cstring:
              headers.set("Location", exception.msg)
              headers.set("Set-Cookie", "session_id=; expires=31-Dec-1999 23:59:59 GMT") # Delete session id
              response = Response(status:Http302, body:"", headers:headers)
            else:
              let status = checkHttpCode(exception)
              response = Response(status:status, body:errorPage(status, exception.msg), headers:headers)
              echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
              echoErrorMsg(exception.msg)
            break middlewareAndApp
          if response.headers.len > 0:
            headers.add(response.headers)
        # web app routes
        let key = $(req.httpMethod) & ":" & req.path
        if routes.withoutParams.hasKey(key):
          let route = routes.withoutParams[key]
          response = await createResponse(req, route, headers)
          isWebApp = true
          break middlewareAndApp
        else:
          for route in routes.withParams:
            if route.httpMethod == req.httpMethod and isMatchUrl(req.path, route.path):
              response = await createResponse(req, route, headers)
              isWebApp = true
              break middlewareAndApp

    if response.isNil:
      headers.set("Content-Type", "text/html; charset=UTF-8")
      response = Response(status:Http404, body:errorPage(Http404, ""), headers:headers)
      echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)

    if not isWebApp and isMiddleware:
      response.headers = headers

    # anonymous user login
    let auth = await newAuth(req)
    if await auth.anonumousCreateSession():
      response = await response.setAuth(auth)
    else:
      var cookie = newCookie(req)
      cookie.updateExpire(SESSION_TIME, Minutes)
      response = response.setCookie(cookie)

    await req.respond(response.status, response.body, response.headers.toResponse())
    # keep-alive
    req.dealKeepAlive()
  waitFor server.serve(Port(port), cb)

proc serve*(routes: var Routes) =
  let port = PORT_NUM
  let numThreads =
    when compileOption("threads"):
      countProcessors()
    else:
      1

  if numThreads == 1:
    echo("Starting 1 thread")
  else:
    echo("Starting ", numThreads, " threads")
  echo("Listening on port ", port)
  when compileOption("threads"):
    var threads = newSeq[Thread[(Routes, int)]](numThreads)
    for i in 0 ..< numThreads:
      createThread(
        threads[i], serveCore, (routes, port)
      )
    joinThreads(threads)
  else:
    serveCore((routes, port))
