import
  asynchttpserver, asyncdispatch, json, strformat, macros, strutils, os,
  asyncfile, mimetypes, re, tables, times
from osproc import countProcessors
import baseEnv, request, response, header, logger, error_page, resources/ddPage,
  security
export request, header


type Route* = ref object
  httpMethod*:HttpMethod
  path*:string
  action*:proc(r:Request, p:Params):Future[Response]

type MiddlewareRoute* = ref object
  httpMethods*:seq[HttpMethod]
  path*:Regex
  action*:proc(r:Request, p:Params):Future[Response]


proc params*(request:Request, route:Route):Params =
  let url = request.path
  let path = route.path
  let params = Params()
  for k, v in getUrlParams(url, path).pairs:
    params[k] = v
  for k, v in getQueryParams(request).pairs:
    params[k] = v

  if request.headers.hasKey("content-type") and request.headers["content-type"].split(";")[0] == "application/json":
    for k, v in getJsonParams(request).pairs:
      params[k] = v
  else:
    for k, v in getRequestParams(request).pairs:
      params[k] = v
  return params

proc params*(request:Request, middleware:MiddlewareRoute):Params =
  let url = request.path
  let path = middleware.path
  let params = Params()
  # for k, v in getUrlParams(url, path).pairs:
  #   params[k] = v
  for k, v in getQueryParams(request).pairs:
    params[k] = v
  for k, v in getRequestParams(request).pairs:
    params[k] = v
  return params

type Routes* = ref object
  withParams: seq[Route]
  withoutParams: OrderedTable[string, Route]
  middlewares: seq[MiddlewareRoute]

proc newRoutes*():Routes =
  return Routes()

proc newRoute(httpMethod:HttpMethod, path:string, action:proc(r:Request, p:Params):Future[Response]):Route =
  return Route(
    httpMethod:httpMethod,
    path:path,
    action:action
  )

proc add*(this:var Routes, httpMethod:HttpMethod, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  let route = newRoute(httpMethod, path, action)
  if path.contains("{"):
    this.withParams.add(route)
  else:
    this.withoutParams[ $httpMethod & ":" & path ] = route
    if not @[HttpGet, HttpHead, HttpPost].contains(httpMethod):
      this.withoutParams[ $(HttpOptions) & ":" & path ] = route

proc middleware*(
  this:var Routes,
  path:Regex,
  action:proc(r:Request, p:Params):Future[Response]
) =
  this.middlewares.add(
    MiddlewareRoute(
      httpMethods: newSeq[HttpMethod](),
      path: path,
      action: action
    )
  )

proc middleware*(
  this:var Routes,
  httpMethods:seq[HttpMethod],
  path:Regex,
  action:proc(r:Request, p:Params):Future[Response]
) =
  this.middlewares.add(
    MiddlewareRoute(
      httpMethods: httpMethods,
      path: path,
      action: action
    )
  )

proc get*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpGet, path, action)

proc post*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPost, path, action)

proc put*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPut, path, action)

proc patch*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpPatch, path, action)

proc delete*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpDelete, path, action)

proc head*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpHead, path, action)

proc options*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpOptions, path, action)

proc trace*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpTrace, path, action)

proc connect*(this:var Routes, path:string, action:proc(r:Request, p:Params):Future[Response]) =
  add(this, HttpConnect, path, action)

macro groups*(head, body:untyped):untyped =
  var newNode = ""
  for row in body:
    let rowNode = fmt"""
{row[0].repr}("{head}{row[1]}", {row[2].repr})
"""
    newNode.add(rowNode)
  return parseStmt(newNode)

const errorStatusArray* = [505, 504, 503, 502, 501, 500, 451, 431, 429, 428, 426,
  422, 421, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406,
  405, 404, 403, 401, 400, 307, 305, 304, 303, 302, 301, 300]

macro createHttpCodeError():untyped =
  var strBody = ""
  for num in errorStatusArray:
    strBody.add(fmt"""
of "Error{num.repr}":
  return Http{num.repr}
""")
  return parseStmt(fmt"""
case $exception.name
{strBody}
else:
  return Http400
""")

proc checkHttpCode(exception:ref Exception):HttpCode =
  ## Generated by macro createHttpCodeError.
  ## List is httpCodeArray
  ## .. code-block:: nim
  ##   case $exception.name
  ##   of Error505:
  ##     return Http505
  ##   of Error504:
  ##     return Http504
  ##   of Error503:
  ##     return Http503
  ##   .
  ##   .
  createHttpCodeError


proc runMiddleware(req:Request, routes:Routes, headers:Headers):Future[Response] {.async, gcsafe.} =
  var
    response = Response()
    headers = headers
    status = HttpCode(0)
  for route in routes.middlewares:
    if route.httpMethods.len > 0:
      if findAll(req.path, route.path).len > 0 and route.httpMethods.contains(req.httpMethod):
        let params = req.params(route)
        response = await route.action(req, params)
    else:
      if findAll(req.path, route.path).len > 0:
        let params = req.params(route)
        response = await route.action(req, params)
    if response.headers.len > 0:
      headers = response.headers & headers
    if response.status != HttpCode(0):
      status = response.status
  response.headers = headers
  response.status = status
  return response

proc runController(req:Request, route:Route, headers: Headers):Future[Response] {.async, gcsafe.} =
  var response: Response
  let params = req.params(route)
  response = await route.action(req, params)
  response.headers = response.headers & headers
  echoLog($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
  return response

proc doesRunAnonymousLogin(req:Request, res:Response):bool =
  if res.isNil:
    return false
  if not ENABLE_ANONYMOUS_COOKIE:
    return false
  if req.httpMethod == HttpOptions:
    return false
  if res.headers.hasKey("set-cookie"):
    return false
  # if not req.headers.hasKey("content-type"):
  #   return false
  # if req.headers["content-type"].split(";")[0] == "application/json":
  #   return false
  return true

proc serveCore(params:(Routes, int)){.thread.} =
  let (routes, port) = params
  var server = newAsyncHttpServer(true, true)

  proc cb(req: Request) {.async, gcsafe.} =
    var
      headers: Headers
      response: Response
    # static file response
    if req.path.contains("."):
      let filepath = getCurrentDir() & "/public" & req.path
      if fileExists(filepath):
        let file = openAsync(filepath, fmRead)
        let data = await file.readAll()
        let contentType = newMimetypes().getMimetype(req.path.split(".")[^1])
        headers.set("Content-Type", contentType)
        response = Response(status:Http200, body:data, headers:headers)
    else:
      # check controller routing
      try:
        let key = $(req.httpMethod) & ":" & req.path
        response = await runMiddleware(req, routes, headers)
        if routes.withoutParams.hasKey(key):
          let route = routes.withoutParams[key]
          if req.httpMethod != HttpOptions:
            headers = headers & response.headers
            response = await runController(req, route, headers)
        else:
          for route in routes.withParams:
            response = await runMiddleware(req, routes, headers)
            if route.httpMethod == req.httpMethod and isMatchUrl(req.path, route.path):
              if req.httpMethod != HttpOptions:
                headers = headers & response.headers
                response = await runController(req, route, headers)
                break
      except:
        headers.set("Content-Type", "text/html; charset=UTF-8")
        let exception = getCurrentException()
        if exception.name == "DD".cstring:
          var msg = exception.msg
          msg = msg.replace(re"Async traceback:[.\s\S]*")
          response = Response(status:Http200, body:ddPage(msg), headers:headers)
        elif exception.name == "ErrorAuthRedirect".cstring:
          headers.set("Location", exception.msg)
          headers.set("Set-Cookie", "session_id=; expires=31-Dec-1999 23:59:59 GMT") # Delete session id
          response = Response(status:Http302, body:"", headers:headers)
        elif exception.name == "ErrorRedirect".cstring:
          headers.set("Location", exception.msg)
          response = Response(status:Http302, body:"", headers:headers)
        else:
          let status = checkHttpCode(exception)
          response = Response(status:status, body:errorPage(status, exception.msg), headers:headers)
          echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
          echoErrorMsg(exception.msg)

      # anonymous user login should run only for response from controler
      if doesRunAnonymousLogin(req, response):
        let auth = await newAuth(req)
        if await auth.anonumousCreateSession():
          response = await response.setAuth(auth)
        else:
          var cookie = newCookie(req)
          cookie.updateExpire(SESSION_TIME, Minutes)
          response = response.setCookie(cookie)

    if response.isNil:
      headers.set("Content-Type", "text/html; charset=UTF-8")
      response = Response(status:Http404, body:errorPage(Http404, ""), headers:headers)
      echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)

    response.headers.setDefaultHeaders()

    await req.respond(response.status, response.body, response.headers.toResponse())
    # keep-alive
    req.dealKeepAlive()
  waitFor server.serve(Port(port), cb)

proc serve*(routes: var Routes) =
  let port = PORT_NUM
  let numThreads =
    when compileOption("threads"):
      countProcessors()
    else:
      1

  if numThreads == 1:
    echo("Starting 1 thread")
  else:
    echo("Starting ", numThreads, " threads")
  echo("Listening on port ", port)
  when compileOption("threads"):
    var threads = newSeq[Thread[(Routes, int)]](numThreads)
    for i in 0 ..< numThreads:
      createThread(
        threads[i], serveCore, (routes, port)
      )
    joinThreads(threads)
  else:
    serveCore((routes, port))
